<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Doc SEA Plugin</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../">
    <link rel="icon" href="images/favicon.ico" />
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@100;200;300;400;600;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="css/template.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css"
        integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-okaidia.css">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.css">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-highlight/prism-line-highlight.css">
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@3.4.6"></script>
    <script src="https://cdn.jsdelivr.net/npm/css-vars-ponyfill@2"></script>
    <script src="js/template.js"></script>
    <script src="js/search.js"></script>
    <script defer src="js/searchIndex.js"></script>
</head>

<body id="top">
    <header class="phpdocumentor-header phpdocumentor-section">
        <h1 class="phpdocumentor-title"><a href="" class="phpdocumentor-title__link">Doc SEA</a></h1>
        <input class="phpdocumentor-header__menu-button" type="checkbox" id="menu-button" name="menu-button" />
        <label class="phpdocumentor-header__menu-icon" for="menu-button">
            <i class="fas fa-bars"></i>
        </label>
        <section data-search-form class="phpdocumentor-search">
            <label>
                <span class="visually-hidden">Search for</span>
                <svg class="phpdocumentor-search__icon" width="21" height="20" viewBox="0 0 21 20" fill="none"
                    xmlns="http://www.w3.org/2000/svg">
                    <circle cx="7.5" cy="7.5" r="6.5" stroke="currentColor" stroke-width="2" />
                    <line x1="12.4892" y1="12.2727" x2="19.1559" y2="18.9393" stroke="currentColor" stroke-width="3" />
                </svg>
                <input type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading .."
                    disabled />
            </label>
        </section>

        <nav class="phpdocumentor-topnav">
            <ul class="phpdocumentor-topnav__menu">
            </ul>
        </nav>
    </header>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <input class="phpdocumentor-sidebar__menu-button" type="checkbox" id="sidebar-button"
                name="sidebar-button" />
            <label class="phpdocumentor-sidebar__menu-icon" for="sidebar-button">
                Menu
            </label>
            <aside class="phpdocumentor-column -three phpdocumentor-sidebar">
                <section class="phpdocumentor-sidebar__category -namespaces">
                    <h2 class="phpdocumentor-sidebar__category-header">
                        <a href="doc-md/index.html" class="-active">Home</a>
                    </h2>
                    <ul class="phpdocumentor-list">
                        <li>
                            <a href="doc-md/standards.html" class="">Standards</a>

                        </li>
                        <li>
                            <a href="doc-md/vscode-setup.html" class="">VSCode</a>

                        </li>
                        <li>
                            <a href="doc-md/docker-tools.html" class="">Docker</a>

                        </li>
                    </ul>

                </section>

                <section class="phpdocumentor-sidebar__category -reports">
                    <h2 class="phpdocumentor-sidebar__category-header">SEA Plugin</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="index.html">Plugin</a>
                    </h3>
                </section>

            </aside>

            <div class="phpdocumentor-column -nine phpdocumentor-content">
                <section>
                    <ul class="phpdocumentor-breadcrumbs">
                    </ul>

                    <article class="phpdocumentor-element -namespace">

                        <h1 id="standards">Standards</h1>
                        <p>Questa è la documentazione per gli standard
                        aziendali.</p>
                        <h2 id="standard-gestione-db">Standard gestione
                        DB</h2>
                        <p>Attualmente il dialogo con il frontend è
                        basato su una struttura MVC leggera che separa
                        backend per tutte le operazioni di editing dei
                        dati, mentre la visualizzazione e la
                        cancellazione dei singoli record avvengono
                        tramite refresh e chiamata diretta PHP ai
                        servizi del plugin di supporto sviluppato
                        internamente.</p>
                        <p>Partendo dal concetto che ogni dato è
                        composto da un record virtuale definito in
                        frontend (tramite form) e che tale record
                        virtuale deve essere restituito al frontend
                        esattamente come il frontend lo consegna al
                        backend, secondo una consolidata pratica delle
                        Settings API WordPress che gestiscono
                        l’amministrazione, tutte le logiche restrostanti
                        che riguardano il trattamento dei dati
                        riguardano il backend.</p>
                        <p>Ad esempio, se un dato univoco è presentanto
                        al backend come JSON, questo per essere
                        sanitizzato verrà prima tradotto e se non ci
                        sono errori, sarà l’oggetto risultante (ad
                        esempio un array) ad essere sanitizzato e poi
                        serializzato (come da standard WordPress) per
                        essere registrato nel database in un singolo
                        campo come stringa. Tuttavia alla successiva
                        necessità di restituire quel dato, la logica
                        verrà rovesciata, il dato sarà letto e
                        deserializzato, quindi codificato in JSON per
                        essere restituito al frontend così come
                        ricevuto, anche nel nome dell’input del
                        POST.</p>
                        <p>Questa procedura standard, può incontrare
                        eccezioni. Ad esempio, un dato nel formato di
                        array potrebbe essere comodo al frontend
                        riceverlo direttamente durante
                        l’inizializzazione della pagina, pensiamo ad
                        esempio alla necessità di inizializzare i campi
                        di una form prima di presentarla all’utente. In
                        questi casi saranno funzioni di wrapping
                        dedicate a restituire dati nella forma più
                        conveniente e tuttavia il nome dei campi di
                        input dovranno sempre rispecchiare quelli del
                        frontend e <strong><em>mai</em></strong> il nome
                        di colonne delle tabelle del database dove
                        finiscono registrati.</p>
                        <p>Ogni SET di classi backend dedicate alla
                        gestione di certi recordset e dataset definiti
                        nella logica di progetto, avranno il compito di
                        essere associate al tipo di dato strutturato di
                        cui si devono occupare e sempre ad una sola
                        tabella. Il SET è composto da tre classi
                        specializzate: una Base, un Admin e una
                        Callback, che ereditano una classe Base per i
                        metodi comuni. Quindi se abbiamo il dato
                        “Category” per la tabella dedicata alle
                        categorie, ci saranno le classi specializzate:
                        BaseCategory, AdminCategory e CategoryCallback.
                        Le differenti Base sono classi che raccolgono e
                        gestiscono le strutture di transcodifica e
                        sanitizzazione del dato nel passaggio da backend
                        a frontend e viceversa.</p>
                        <p>L’esempio delle categorie è calzante per
                        capire la logica con cui si è deciso di
                        procedere per questo standard: si tratta di una
                        tabella di base con record composti da poco più
                        che coppie “chiave =&gt; valore”, dove ogni
                        record-categoria può raggruppare N sottocagorie
                        organizzate nello stesso identico modo. Il
                        limite imposto è che non si devono mai avere
                        coppie “cagegoria + sottocategoria” identiche.
                        Sono quindi state create due tabelle distinte
                        strutturalmente simili e legate tra loro da
                        opportuni constraint. Ogni tabella è gestita da
                        un SET di classi dedicate come già esposto.
                        Tuttavia le classi Base, pur seguendo il
                        principio che <strong><em>ogni istanza deve
                        essere sempre l’unica esperta per il trattamento
                        dei suoi propri dati</em></strong> (a questo
                        proposito PHP ha comportamenti che non
                        garantiscono nativamente questa aspettativa come
                        qui avanti chiarito) vengono messe in relazione
                        di ereditarietà, per riflettere il fatto che le
                        sottocategorie devono conoscere anche le
                        categorie di appartenenza e restituire recordset
                        completi con tutti i dati delle due classi (ad
                        esempio con QUERY LEFT OUTER JOIN o
                        equivalenti).</p>
                        <p>PHP segue il flusso di composizione del suo
                        STDOUT per il render della pagina HTML dinamica.
                        WordPress segue invece una logica più complessa,
                        nativamente costruita attorno a callback. Non è
                        quindi sempre garantito che un certo dato,
                        trattato a un certo punto del flusso, sia
                        disponibile internamente a una certa callback.
                        Tuttavia le chiamate in frontend seguono
                        strutturalmente quelle del backend e quindi
                        siamo ragionevolmente certi che al momento
                        dell’esecuzione del codice in frontend, tutte le
                        classi del plugin di backend sono istanziate e
                        disponibili. Per ciò le funzioni di wrapping per
                        la chiamata diretta verso il plugin, prelevano
                        prima l’istanza salvata durante in processo di
                        inizializzazione nella stessa request, che sarà
                        quindi sempre condivisa, poi i metodi relativi
                        di quell’istanza.</p>
                        <h4
                        id="php-e-overloading-perdita-degli-attributi">PHP
                        e overloading: perdita degli attributi</h4>
                        <p>Se c’è un attributo di classe
                        <code>$table</code> con il nome della tabella,
                        mettiamo “<em>wp_sea_categories</em>”, assegnato
                        all’istanza di classe BaseCategory chiamata
                        dentro l’istanza figlia BaseSubcategory che ha
                        identico attributo <code>$table</code>
                        valorizzato invece con
                        “<em>wp_sea_subcategories</em>” e chiedo
                        all’istanza figlia BaseCategory qual’è il SUO
                        valore <code>$table</code>, mi risponderà sempre
                        “<em>wp_sea_subcategories</em>” anche se mi
                        trovo nel metodo definito in BaseCategory che
                        restituisce il suo proprio dato privato
                        <code>$table</code>, perché l’overloading PHP
                        dei dati <strong><em>privati</em></strong> di
                        classe, nell’ereditarietà, segue il principio
                        del flusso e “<em>sovrascrive</em>” rendendo
                        oltrettutto irraggiungibile il dato originario
                        sottostante. La soluzione (che l’autore
                        disapprova) standard PHP è quella di dichiarare
                        l’attributo oltre che privato anche statico e
                        quindi condiviso con tutte le istanze di quella
                        classe. Se per un attributo come
                        <code>$table</code> può andare bene, non è di
                        certo una soluzione sempre praticabile e quindi
                        generalizzabile.</p>
                        <p>Abbiamo quindi optato per una classe Trait
                        che rende abile l’istanza ad eseguire snapshot
                        nei punti “<em>caldi</em>” (come nel
                        costruttore) ove gli attributi privati vengono
                        modificati, come nei metodi set, in grado di
                        rendere disponibile “<em>una copia di
                        salvataggio</em>” che rimane accessibile tramite
                        get. Certamente è un compromesso, ma abbastanza
                        flessibile, preciso, semplice e robusto.</p>
                        <h2
                        id="standard-per-le-chiamate-al-plugin-sea">Standard
                        per le chiamate al plugin SEA</h2>
                        <p>Abbiamo previsto i seguenti metodi di
                        interfacciamento ai dati: - SITO PUBBLICATO: -
                        AJAX, via fetch POST JS, per l’editig - REST
                        API, per i blocchi dataset paginati - Funzioni
                        di wrapping, per l’inizializzazione e la
                        cancellazione - AMMINISTRAZIONE: - Settings API
                        WordPress - Interfaccia diretta e dedicata alle
                        classi</p>
                        <hr />
                        <h2 id="ambiente-vscode">Ambiente VSCode</h2>
                        <p>Consulta <a
                        href="vscode-setup.html">Configurazione
                        consigliata</a></p>
                        <h2 id="docker">Docker</h2>
                        <p>Consulta <a
                        href="docker-tools.html">Strumenti
                        principali</a></p>


                    </article>
                </section>
                <section class="phpdocumentor-on-this-page__sidebar">

                    <section class="phpdocumentor-on-this-page__content">
                        <strong class="phpdocumentor-on-this-page__title">On this page</strong>

                        <ul class="phpdocumentor-list -clean">
                            <li class="phpdocumentor-on-this-page-section__title">Table Of Contents</li>
                            
                            <!--
                            <li>
                                <ul class="phpdocumentor-list -clean">
                                    <li><a href="doc-md/nome_di_questo_file.html#toc-classes">Benvenuto</a></li>
                                </ul>
                                ...
                            </li>
                            -->


                        </ul>
                    </section>

                </section>
            </div>
            <section data-search-results class="phpdocumentor-search-results phpdocumentor-search-results--hidden">
                <section class="phpdocumentor-search-results__dialog">
                    <header class="phpdocumentor-search-results__header">
                        <h2 class="phpdocumentor-search-results__title">Search results</h2>
                        <button class="phpdocumentor-search-results__close"><i class="fas fa-times"></i></button>
                    </header>
                    <section class="phpdocumentor-search-results__body">
                        <ul class="phpdocumentor-search-results__entries"></ul>
                    </section>
                </section>
            </section>
        </div>
        <a href="namespaces/glib.html#top" class="phpdocumentor-back-to-top"><i
                class="fas fa-chevron-circle-up"></i></a>

    </main>

    <script>
        cssVars({});
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
</body>

</html>